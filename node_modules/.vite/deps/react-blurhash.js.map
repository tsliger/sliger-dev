{
  "version": 3,
  "sources": ["../../react-blurhash/src/Blurhash.tsx", "../../react-blurhash/src/BlurhashCanvas.tsx", "../../blurhash/src/base83.ts", "../../blurhash/src/utils.ts", "../../blurhash/src/error.ts", "../../blurhash/src/decode.ts", "../../blurhash/src/encode.ts"],
  "sourcesContent": ["import * as React from 'react';\n\nimport BlurhashCanvas from './BlurhashCanvas';\n\ntype Props = React.HTMLAttributes<HTMLDivElement> & {\n  hash: string;\n  /** CSS height, default: 128 */\n  height?: number | string | 'auto';\n  punch?: number;\n  resolutionX?: number;\n  resolutionY?: number;\n  style?: React.CSSProperties;\n  /** CSS width, default: 128 */\n  width?: number | string | 'auto';\n};\n\nconst canvasStyle: React.CSSProperties = {\n  position: 'absolute',\n  top: 0,\n  bottom: 0,\n  left: 0,\n  right: 0,\n  width: '100%',\n  height: '100%',\n};\n\nexport default class Blurhash extends React.PureComponent<Props> {\n  static defaultProps = {\n    height: 128,\n    width: 128,\n    resolutionX: 32,\n    resolutionY: 32,\n  };\n\n  componentDidUpdate() {\n    if (this.props.resolutionX <= 0) {\n      throw new Error('resolutionX must be larger than zero');\n    }\n\n    if (this.props.resolutionY <= 0) {\n      throw new Error('resolutionY must be larger than zero');\n    }\n  }\n\n  render() {\n    const { hash, height, width, punch, resolutionX, resolutionY, style, ...rest } = this.props;\n\n    return (\n      <div\n        {...rest}\n        style={{ display: 'inline-block', height, width, ...style, position: 'relative' }}\n      >\n        <BlurhashCanvas\n          hash={hash}\n          height={resolutionY}\n          width={resolutionX}\n          punch={punch}\n          style={canvasStyle}\n        />\n      </div>\n    );\n  }\n}\n", "import * as React from 'react';\nimport { decode } from 'blurhash';\n\nexport type Props = React.CanvasHTMLAttributes<HTMLCanvasElement> & {\n  hash: string;\n  height?: number;\n  punch?: number;\n  width?: number;\n};\n\nexport default class BlurhashCanvas extends React.PureComponent<Props> {\n  static defaultProps = {\n    height: 128,\n    width: 128,\n  };\n\n  canvas: HTMLCanvasElement = null;\n\n  componentDidUpdate() {\n    this.draw();\n  }\n\n  handleRef = (canvas: HTMLCanvasElement) => {\n    this.canvas = canvas;\n    this.draw();\n  };\n\n  draw = () => {\n    const { hash, height, punch, width } = this.props;\n\n    if (this.canvas) {\n      const pixels = decode(hash, width, height, punch);\n\n      const ctx = this.canvas.getContext('2d');\n      const imageData = ctx.createImageData(width, height);\n      imageData.data.set(pixels);\n      ctx.putImageData(imageData, 0, 0);\n    }\n  };\n\n  render() {\n    const { hash, height, width, ...rest } = this.props;\n\n    return <canvas {...rest} height={height} width={width} ref={this.handleRef} />;\n  }\n}\n", "const digitCharacters = [\n  \"0\",\n  \"1\",\n  \"2\",\n  \"3\",\n  \"4\",\n  \"5\",\n  \"6\",\n  \"7\",\n  \"8\",\n  \"9\",\n  \"A\",\n  \"B\",\n  \"C\",\n  \"D\",\n  \"E\",\n  \"F\",\n  \"G\",\n  \"H\",\n  \"I\",\n  \"J\",\n  \"K\",\n  \"L\",\n  \"M\",\n  \"N\",\n  \"O\",\n  \"P\",\n  \"Q\",\n  \"R\",\n  \"S\",\n  \"T\",\n  \"U\",\n  \"V\",\n  \"W\",\n  \"X\",\n  \"Y\",\n  \"Z\",\n  \"a\",\n  \"b\",\n  \"c\",\n  \"d\",\n  \"e\",\n  \"f\",\n  \"g\",\n  \"h\",\n  \"i\",\n  \"j\",\n  \"k\",\n  \"l\",\n  \"m\",\n  \"n\",\n  \"o\",\n  \"p\",\n  \"q\",\n  \"r\",\n  \"s\",\n  \"t\",\n  \"u\",\n  \"v\",\n  \"w\",\n  \"x\",\n  \"y\",\n  \"z\",\n  \"#\",\n  \"$\",\n  \"%\",\n  \"*\",\n  \"+\",\n  \",\",\n  \"-\",\n  \".\",\n  \":\",\n  \";\",\n  \"=\",\n  \"?\",\n  \"@\",\n  \"[\",\n  \"]\",\n  \"^\",\n  \"_\",\n  \"{\",\n  \"|\",\n  \"}\",\n  \"~\",\n];\n\nexport const decode83 = (str: String) => {\n  let value = 0;\n  for (let i = 0; i < str.length; i++) {\n    const c = str[i];\n    const digit = digitCharacters.indexOf(c);\n    value = value * 83 + digit;\n  }\n  return value;\n};\n\nexport const encode83 = (n: number, length: number): string => {\n  var result = \"\";\n  for (let i = 1; i <= length; i++) {\n    let digit = (Math.floor(n) / Math.pow(83, length - i)) % 83;\n    result += digitCharacters[Math.floor(digit)];\n  }\n  return result;\n};\n", "export const sRGBToLinear = (value: number) => {\n  let v = value / 255;\n  if (v <= 0.04045) {\n    return v / 12.92;\n  } else {\n    return Math.pow((v + 0.055) / 1.055, 2.4);\n  }\n};\n\nexport const linearTosRGB = (value: number) => {\n  let v = Math.max(0, Math.min(1, value));\n  if (v <= 0.0031308) {\n    return Math.trunc(v * 12.92 * 255 + 0.5);\n  } else {\n    return Math.trunc((1.055 * Math.pow(v, 1 / 2.4) - 0.055) * 255 + 0.5);\n  }\n};\n\nexport const sign = (n: number) => (n < 0 ? -1 : 1);\n\nexport const signPow = (val: number, exp: number) =>\n  sign(val) * Math.pow(Math.abs(val), exp);\n", "export class ValidationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"ValidationError\";\n    this.message = message;\n  }\n}\n", "import { decode83 } from \"./base83\";\nimport { sRGBToLinear, signPow, linearTosRGB } from \"./utils\";\nimport { ValidationError } from \"./error\";\n\n/**\n * Returns an error message if invalid or undefined if valid\n * @param blurhash\n */\nconst validateBlurhash = (blurhash: string) => {\n  if (!blurhash || blurhash.length < 6) {\n    throw new ValidationError(\n      \"The blurhash string must be at least 6 characters\"\n    );\n  }\n\n  const sizeFlag = decode83(blurhash[0]);\n  const numY = Math.floor(sizeFlag / 9) + 1;\n  const numX = (sizeFlag % 9) + 1;\n\n  if (blurhash.length !== 4 + 2 * numX * numY) {\n    throw new ValidationError(\n      `blurhash length mismatch: length is ${\n        blurhash.length\n      } but it should be ${4 + 2 * numX * numY}`\n    );\n  }\n};\n\nexport const isBlurhashValid = (\n  blurhash: string\n): { result: boolean; errorReason?: string } => {\n  try {\n    validateBlurhash(blurhash);\n  } catch (error) {\n    return { result: false, errorReason: error.message };\n  }\n\n  return { result: true };\n};\n\nconst decodeDC = (value: number) => {\n  const intR = value >> 16;\n  const intG = (value >> 8) & 255;\n  const intB = value & 255;\n  return [sRGBToLinear(intR), sRGBToLinear(intG), sRGBToLinear(intB)];\n};\n\nconst decodeAC = (value: number, maximumValue: number) => {\n  const quantR = Math.floor(value / (19 * 19));\n  const quantG = Math.floor(value / 19) % 19;\n  const quantB = value % 19;\n\n  const rgb = [\n    signPow((quantR - 9) / 9, 2.0) * maximumValue,\n    signPow((quantG - 9) / 9, 2.0) * maximumValue,\n    signPow((quantB - 9) / 9, 2.0) * maximumValue,\n  ];\n\n  return rgb;\n};\n\nconst decode = (\n  blurhash: string,\n  width: number,\n  height: number,\n  punch?: number\n) => {\n  validateBlurhash(blurhash);\n\n  punch = punch | 1;\n\n  const sizeFlag = decode83(blurhash[0]);\n  const numY = Math.floor(sizeFlag / 9) + 1;\n  const numX = (sizeFlag % 9) + 1;\n\n  const quantisedMaximumValue = decode83(blurhash[1]);\n  const maximumValue = (quantisedMaximumValue + 1) / 166;\n\n  const colors = new Array(numX * numY);\n\n  for (let i = 0; i < colors.length; i++) {\n    if (i === 0) {\n      const value = decode83(blurhash.substring(2, 6));\n      colors[i] = decodeDC(value);\n    } else {\n      const value = decode83(blurhash.substring(4 + i * 2, 6 + i * 2));\n      colors[i] = decodeAC(value, maximumValue * punch);\n    }\n  }\n\n  const bytesPerRow = width * 4;\n  const pixels = new Uint8ClampedArray(bytesPerRow * height);\n\n  for (let y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++) {\n      let r = 0;\n      let g = 0;\n      let b = 0;\n\n      for (let j = 0; j < numY; j++) {\n        for (let i = 0; i < numX; i++) {\n          const basis =\n            Math.cos((Math.PI * x * i) / width) *\n            Math.cos((Math.PI * y * j) / height);\n          let color = colors[i + j * numX];\n          r += color[0] * basis;\n          g += color[1] * basis;\n          b += color[2] * basis;\n        }\n      }\n\n      let intR = linearTosRGB(r);\n      let intG = linearTosRGB(g);\n      let intB = linearTosRGB(b);\n\n      pixels[4 * x + 0 + y * bytesPerRow] = intR;\n      pixels[4 * x + 1 + y * bytesPerRow] = intG;\n      pixels[4 * x + 2 + y * bytesPerRow] = intB;\n      pixels[4 * x + 3 + y * bytesPerRow] = 255; // alpha\n    }\n  }\n  return pixels;\n};\n\nexport default decode;\n", "import { encode83 } from \"./base83\";\nimport { sRGBToLinear, signPow, linearTosRGB } from \"./utils\";\nimport { ValidationError } from \"./error\";\n\ntype NumberTriplet = [number, number, number];\n\nconst bytesPerPixel = 4;\n\nconst multiplyBasisFunction = (\n  pixels: Uint8ClampedArray,\n  width: number,\n  height: number,\n  basisFunction: (i: number, j: number) => number\n): NumberTriplet => {\n  let r = 0;\n  let g = 0;\n  let b = 0;\n  const bytesPerRow = width * bytesPerPixel;\n\n  for (let x = 0; x < width; x++) {\n    const bytesPerPixelX = bytesPerPixel * x;\n\n    for (let y = 0; y < height; y++) {\n      const basePixelIndex = bytesPerPixelX + y * bytesPerRow;\n      const basis = basisFunction(x, y);\n      r +=\n        basis * sRGBToLinear(pixels[basePixelIndex]);\n      g +=\n        basis * sRGBToLinear(pixels[basePixelIndex + 1]);\n      b +=\n        basis * sRGBToLinear(pixels[basePixelIndex + 2]);\n    }\n  }\n\n  let scale = 1 / (width * height);\n\n  return [r * scale, g * scale, b * scale];\n};\n\nconst encodeDC = (value: NumberTriplet): number => {\n  const roundedR = linearTosRGB(value[0]);\n  const roundedG = linearTosRGB(value[1]);\n  const roundedB = linearTosRGB(value[2]);\n  return (roundedR << 16) + (roundedG << 8) + roundedB;\n};\n\nconst encodeAC = (value: NumberTriplet, maximumValue: number): number => {\n  let quantR = Math.floor(\n    Math.max(\n      0,\n      Math.min(18, Math.floor(signPow(value[0] / maximumValue, 0.5) * 9 + 9.5))\n    )\n  );\n  let quantG = Math.floor(\n    Math.max(\n      0,\n      Math.min(18, Math.floor(signPow(value[1] / maximumValue, 0.5) * 9 + 9.5))\n    )\n  );\n  let quantB = Math.floor(\n    Math.max(\n      0,\n      Math.min(18, Math.floor(signPow(value[2] / maximumValue, 0.5) * 9 + 9.5))\n    )\n  );\n\n  return quantR * 19 * 19 + quantG * 19 + quantB;\n};\n\nconst encode = (\n  pixels: Uint8ClampedArray,\n  width: number,\n  height: number,\n  componentX: number,\n  componentY: number\n): string => {\n  if (componentX < 1 || componentX > 9 || componentY < 1 || componentY > 9) {\n    throw new ValidationError(\"BlurHash must have between 1 and 9 components\");\n  }\n  if (width * height * 4 !== pixels.length) {\n    throw new ValidationError(\"Width and height must match the pixels array\");\n  }\n\n  let factors: Array<[number, number, number]> = [];\n  for (let y = 0; y < componentY; y++) {\n    for (let x = 0; x < componentX; x++) {\n      const normalisation = x == 0 && y == 0 ? 1 : 2;\n      const factor = multiplyBasisFunction(\n        pixels,\n        width,\n        height,\n        (i: number, j: number) =>\n          normalisation *\n          Math.cos((Math.PI * x * i) / width) *\n          Math.cos((Math.PI * y * j) / height)\n      );\n      factors.push(factor);\n    }\n  }\n\n  const dc = factors[0];\n  const ac = factors.slice(1);\n\n  let hash = \"\";\n\n  let sizeFlag = componentX - 1 + (componentY - 1) * 9;\n  hash += encode83(sizeFlag, 1);\n\n  let maximumValue: number;\n  if (ac.length > 0) {\n    let actualMaximumValue = Math.max(...ac.map((val) => Math.max(...val)));\n    let quantisedMaximumValue = Math.floor(\n      Math.max(0, Math.min(82, Math.floor(actualMaximumValue * 166 - 0.5)))\n    );\n    maximumValue = (quantisedMaximumValue + 1) / 166;\n    hash += encode83(quantisedMaximumValue, 1);\n  } else {\n    maximumValue = 1;\n    hash += encode83(0, 1);\n  }\n\n  hash += encode83(encodeDC(dc), 4);\n\n  ac.forEach((factor) => {\n    hash += encode83(encodeAC(factor, maximumValue), 2);\n  });\n\n  return hash;\n};\n\nexport default encode;\n"],
  "mappings": ";;;;;;;;AAAA,QAAuB;ACAvB,IAAAA,KAAuB;;;ACAvB,IAAM,IAAkB,CACtB,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,GACF;AApFA,IAsFa,IAAY,OAAgB;AACvC,MAAI,IAAQ;AACZ,WAAS,IAAI,GAAG,IAAI,EAAI,QAAQ,KAAK;AACnC,QAAM,IAAI,EAAI,CAAA,GACRC,KAAQ,EAAgB,QAAQ,CAAC;AACvC,QAAQ,IAAQ,KAAKA;EACvB;AACA,SAAO;AACT;AC9FO,IAAM,IAAgB,OAAkB;AAC7C,MAAI,IAAI,IAAQ;AAChB,SAAI,KAAK,UACA,IAAI,QAEJ,KAAK,KAAK,IAAI,SAAS,OAAO,GAAG;AAE5C;AAPO,IASM,IAAgB,OAAkB;AAC7C,MAAI,IAAI,KAAK,IAAI,GAAG,KAAK,IAAI,GAAG,CAAK,CAAC;AACtC,SAAI,KAAK,WACA,KAAK,MAAM,IAAI,QAAQ,MAAM,GAAG,IAEhC,KAAK,OAAO,QAAQ,KAAK,IAAI,GAAG,kBAAO,IAAI,SAAS,MAAM,GAAG;AAExE;AAhBO,IAkBM,IAAQ,OAAe,IAAI,IAAI,KAAK;AAlB1C,IAoBM,IAAU,CAAC,GAAa,MACnC,EAAK,CAAG,IAAI,KAAK,IAAI,KAAK,IAAI,CAAG,GAAG,CAAG;ACrBlC,IAAM,IAAN,cAA8B,MAAM;EACzC,YAAY,GAAiB;AAC3B,UAAM,CAAO,GACb,KAAK,OAAO,mBACZ,KAAK,UAAU;EACjB;AACF;ACEA,IAAM,IAAoB,OAAqB;AAC7C,MAAI,CAAC,KAAY,EAAS,SAAS;AACjC,UAAM,IAAI,EACR,mDACF;AAGF,MAAM,IAAW,EAAS,EAAS,CAAA,CAAE,GAC/B,IAAO,KAAK,MAAM,IAAW,CAAC,IAAI,GAClC,IAAQ,IAAW,IAAK;AAE9B,MAAI,EAAS,WAAW,IAAI,IAAI,IAAO;AACrC,UAAM,IAAI,EACR,uCACE,EAAS,2BACU,IAAI,IAAI,IAAO,GACtC;AAEJ;AAlBA,IAgCM,IAAY,OAAkB;AAClC,MAAM,IAAO,KAAS,IAChB,IAAQ,KAAS,IAAK,KACtB,IAAO,IAAQ;AACrB,SAAO,CAAC,EAAa,CAAI,GAAG,EAAa,CAAI,GAAG,EAAa,CAAI,CAAC;AACpE;AArCA,IAuCM,IAAW,CAAC,GAAe,MAAyB;AACxD,MAAM,IAAS,KAAK,MAAM,IAAS,GAAQ,GACrC,IAAS,KAAK,MAAM,IAAQ,EAAE,IAAI,IAClCC,KAAS,IAAQ;AAQvB,SANY,CACV,GAAS,IAAS,KAAK,GAAG,CAAG,IAAI,GACjC,GAAS,IAAS,KAAK,GAAG,CAAG,IAAI,GACjC,GAASA,KAAS,KAAK,GAAG,CAAG,IAAI,CACnC;AAGF;AAnDA,IAqDM,IAAS,CACb,GACA,GACA,GACA,MACG;AACH,IAAiB,CAAQ,GAEzB,IAAQ,IAAQ;AAEhB,MAAMA,KAAW,EAAS,EAAS,CAAA,CAAE,GAC/BC,KAAO,KAAK,MAAMD,KAAW,CAAC,IAAI,GAClCE,KAAQF,KAAW,IAAK,GAGxB,KADwB,EAAS,EAAS,CAAA,CAAE,IACJ,KAAK,KAE7CG,KAAS,IAAI,MAAMD,KAAOD,EAAI;AAEpC,WAASG,KAAI,GAAGA,KAAID,GAAO,QAAQC;AACjC,QAAIA,OAAM,GAAG;AACX,UAAM,IAAQ,EAAS,EAAS,UAAU,GAAG,CAAC,CAAC;AAC/C,MAAAD,GAAOC,EAAA,IAAK,EAAS,CAAK;IAC5B,OAAO;AACL,UAAM,IAAQ,EAAS,EAAS,UAAU,IAAIA,KAAI,GAAG,IAAIA,KAAI,CAAC,CAAC;AAC/D,MAAAD,GAAOC,EAAA,IAAK,EAAS,GAAO,IAAe,CAAK;IAClD;AAGF,MAAM,IAAc,IAAQ,GACtB,IAAS,IAAI,kBAAkB,IAAc,CAAM;AAEzD,WAASA,KAAI,GAAGA,KAAI,GAAQA;AAC1B,aAAS,IAAI,GAAG,IAAI,GAAO,KAAK;AAC9B,UAAI,IAAI,GACJ,IAAI,GACJC,KAAI;AAER,eAAS,IAAI,GAAG,IAAIJ,IAAM;AACxB,iBAASK,KAAI,GAAGA,KAAIJ,IAAMI,MAAK;AAC7B,cAAM,IACJ,KAAK,IAAK,KAAK,KAAK,IAAIA,KAAK,CAAK,IAClC,KAAK,IAAK,KAAK,KAAKF,KAAI,IAAK,CAAM,GACjC,IAAQD,GAAOG,KAAI,IAAIJ,EAAA;AAC3B,eAAK,EAAM,CAAA,IAAK,GAChB,KAAK,EAAM,CAAA,IAAK,GAChBG,MAAK,EAAM,CAAA,IAAK;QAClB;AAGF,UAAI,IAAO,EAAa,CAAC,GACrB,IAAO,EAAa,CAAC,GACrB,IAAO,EAAaA,EAAC;AAEzB,QAAO,IAAI,IAAI,IAAID,KAAI,CAAA,IAAe,GACtC,EAAO,IAAI,IAAI,IAAIA,KAAI,CAAA,IAAe,GACtC,EAAO,IAAI,IAAI,IAAIA,KAAI,CAAA,IAAe,GACtC,EAAO,IAAI,IAAI,IAAIA,KAAI,CAAA,IAAe;IACxC;AAEF,SAAO;AACT;AAlHA,IAoHO,IAAQ;;;;;;;;;;;;;;;;;;;;;;;;;;;;AJlHf,IAAqBG,IAArB,cAAkD,iBAAqB;EAAvE,cAAA;AAAA,UAAA,GAAA,SAAA;AAME,SAAA,SAA4B;AAM5B,SAAA,YAAaC,OAA8B;AACzC,WAAK,SAASA,GACd,KAAK,KAAK;IACZ;AAEA,SAAA,OAAO,MAAM;AACX,UAAM,EAAE,MAAAC,GAAM,QAAAC,GAAQ,OAAAC,GAAO,OAAAC,EAAM,IAAI,KAAK;AAE5C,UAAI,KAAK,QAAQ;AACf,YAAMC,IAASC,EAAOL,GAAMG,GAAOF,GAAQC,CAAK,GAE1CI,IAAM,KAAK,OAAO,WAAW,IAAI,GACjCC,KAAYD,EAAI,gBAAgBH,GAAOF,CAAM;AACnDM,QAAAA,GAAU,KAAK,IAAIH,CAAM,GACzBE,EAAI,aAAaC,IAAW,GAAG,CAAC;MAClC;IACF;EAAA;EApBA,qBAAqB;AACnB,SAAK,KAAK;EACZ;EAoBA,SAAS;AACP,QAAyCC,IAAA,KAAK,OAAtC,EAAA,MAAAR,GAAM,QAAAC,GAAQ,OAAAE,EAzC1B,IAyC6CK,GAATC,IAAAC,EAASF,GAAT,CAAxB,QAAM,UAAQ,OAAA,CAAA;AAEtB,WAAO,iBAAC,UAAAG,EAAAC,GAAA,CAAA,GAAWH,CAAAA,GAAX,EAAiB,QAAQR,GAAQ,OAAOE,GAAO,KAAK,KAAK,UAAA,CAAA,CAAW;EAC9E;AACF;AAnCqBL,EACZ,eAAe,EACpB,QAAQ,KACR,OAAO,IACT;ADEF,IAAMe,IAAmC,EACvC,UAAU,YACV,KAAK,GACL,QAAQ,GACR,MAAM,GACN,OAAO,GACP,OAAO,QACP,QAAQ,OACV;AARA,IAUqBC,IAArB,cAA4C,gBAAqB;EAQ/D,qBAAqB;AACnB,QAAI,KAAK,MAAM,eAAe;AAC5B,YAAM,IAAI,MAAM,sCAAsC;AAGxD,QAAI,KAAK,MAAM,eAAe;AAC5B,YAAM,IAAI,MAAM,sCAAsC;EAE1D;EAEA,SAAS;AACP,QAAiFN,IAAA,KAAK,OAA9E,EAAA,MAAAR,GAAM,QAAAC,GAAQ,OAAAE,GAAO,OAAAD,GAAO,aAAAa,GAAa,aAAAC,GAAa,OAAAC,EA7ClE,IA6CqFT,GAATC,KAAAC,EAASF,GAAT,CAAhE,QAAM,UAAQ,SAAO,SAAO,eAAa,eAAa,OAAA,CAAA;AAE9D,WACE,gBAAC,OAAAG,EAAAC,GAAA,CAAA,GACKH,EAAAA,GADL,EAEC,OAAOE,EAAAC,GAAA,EAAE,SAAS,gBAAgB,QAAAX,GAAQ,OAAAE,EAAAA,GAAUc,CAAAA,GAA7C,EAAoD,UAAU,WAAW,CAAA,EAAA,CAAA,GAEhF,gBAACnB,GAAA,EACC,MAAME,GACN,QAAQgB,GACR,OAAOD,GACP,OAAOb,GACP,OAAOW,EAAAA,CACT,CACF;EAEJ;AACF;AApCqBC,EACZ,eAAe,EACpB,QAAQ,KACR,OAAO,KACP,aAAa,IACb,aAAa,GACf;",
  "names": ["f", "l", "l", "m", "b", "u", "o", "R", "P", "BlurhashCanvas", "canvas", "hash", "height", "punch", "width", "pixels", "decode", "ctx", "imageData", "_a", "rest", "__objRest", "__spreadProps", "__spreadValues", "canvasStyle", "Blurhash", "resolutionX", "resolutionY", "style"]
}
