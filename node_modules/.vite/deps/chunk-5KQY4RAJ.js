// node_modules/nanostores/clean-stores/index.js
var clean = Symbol("clean");

// node_modules/nanostores/lifecycle/index.js
var MOUNT = 5;
var UNMOUNT = 6;
var REVERT_MUTATION = 10;
var on = (object, listener, eventKey, mutateStore) => {
  object.events = object.events || {};
  if (!object.events[eventKey + REVERT_MUTATION]) {
    object.events[eventKey + REVERT_MUTATION] = mutateStore((eventProps) => {
      object.events[eventKey].reduceRight((event, l) => (l(event), event), {
        shared: {},
        ...eventProps
      });
    });
  }
  object.events[eventKey] = object.events[eventKey] || [];
  object.events[eventKey].push(listener);
  return () => {
    let currentListeners = object.events[eventKey];
    let index = currentListeners.indexOf(listener);
    currentListeners.splice(index, 1);
    if (!currentListeners.length) {
      delete object.events[eventKey];
      object.events[eventKey + REVERT_MUTATION]();
      delete object.events[eventKey + REVERT_MUTATION];
    }
  };
};
var STORE_UNMOUNT_DELAY = 1e3;
var onMount = (store, initialize) => {
  let listener = (payload) => {
    let destroy = initialize(payload);
    if (destroy)
      store.events[UNMOUNT].push(destroy);
  };
  return on(store, listener, MOUNT, (runListeners) => {
    let originListen = store.listen;
    store.listen = (...args) => {
      if (!store.lc && !store.active) {
        store.active = true;
        runListeners();
      }
      return originListen(...args);
    };
    let originOff = store.off;
    store.events[UNMOUNT] = [];
    store.off = () => {
      originOff();
      setTimeout(() => {
        if (store.active && !store.lc) {
          store.active = false;
          for (let destroy of store.events[UNMOUNT])
            destroy();
          store.events[UNMOUNT] = [];
        }
      }, STORE_UNMOUNT_DELAY);
    };
    if (true) {
      let originClean = store[clean];
      store[clean] = () => {
        for (let destroy of store.events[UNMOUNT])
          destroy();
        store.events[UNMOUNT] = [];
        store.active = false;
        originClean();
      };
    }
    return () => {
      store.listen = originListen;
      store.off = originOff;
    };
  });
};

// node_modules/nanostores/listen-keys/index.js
function listenKeys(store, keys, listener) {
  let keysSet = /* @__PURE__ */ new Set([...keys, void 0]);
  return store.listen((value, changed) => {
    if (keysSet.has(changed)) {
      listener(value, changed);
    }
  });
}

// node_modules/nanostores/atom/index.js
var listenerQueue = [];
var notifyId = 0;
var atom = (initialValue, level) => {
  let currentListeners;
  let nextListeners = [];
  let store = {
    lc: 0,
    l: level || 0,
    value: initialValue,
    set(data) {
      store.value = data;
      store.notify();
    },
    get() {
      if (!store.lc) {
        store.listen(() => {
        })();
      }
      return store.value;
    },
    notify(changedKey) {
      currentListeners = nextListeners;
      let runListenerQueue = !listenerQueue.length;
      for (let i = 0; i < currentListeners.length; i += 2) {
        listenerQueue.push(
          currentListeners[i],
          store.value,
          changedKey,
          currentListeners[i + 1]
        );
      }
      if (runListenerQueue) {
        notifyId++;
        for (let i = 0; i < listenerQueue.length; i += 4) {
          let skip = false;
          for (let j = i + 7; j < listenerQueue.length; j += 4) {
            if (listenerQueue[j] < listenerQueue[i + 3]) {
              skip = true;
              break;
            }
          }
          if (skip) {
            listenerQueue.push(
              listenerQueue[i],
              listenerQueue[i + 1],
              listenerQueue[i + 2],
              listenerQueue[i + 3]
            );
          } else {
            listenerQueue[i](listenerQueue[i + 1], listenerQueue[i + 2]);
          }
        }
        listenerQueue.length = 0;
      }
    },
    listen(listener, listenerLevel) {
      if (nextListeners === currentListeners) {
        nextListeners = nextListeners.slice();
      }
      store.lc = nextListeners.push(listener, listenerLevel || store.l) / 2;
      return () => {
        if (nextListeners === currentListeners) {
          nextListeners = nextListeners.slice();
        }
        let index = nextListeners.indexOf(listener);
        if (~index) {
          nextListeners.splice(index, 2);
          store.lc--;
          if (!store.lc)
            store.off();
        }
      };
    },
    subscribe(cb, listenerLevel) {
      let unbind = store.listen(cb, listenerLevel);
      cb(store.value);
      return unbind;
    },
    off() {
    }
    /* It will be called on last listener unsubscribing.
       We will redefine it in onMount and onStop. */
  };
  if (true) {
    store[clean] = () => {
      nextListeners = [];
      store.lc = 0;
      store.off();
    };
  }
  return store;
};

// node_modules/nanostores/map/index.js
var map = (value = {}) => {
  let store = atom(value);
  store.setKey = function(key, newValue) {
    if (typeof newValue === "undefined") {
      if (key in store.value) {
        store.value = { ...store.value };
        delete store.value[key];
        store.notify(key);
      }
    } else if (store.value[key] !== newValue) {
      store.value = {
        ...store.value,
        [key]: newValue
      };
      store.notify(key);
    }
  };
  return store;
};

// node_modules/nanostores/action/index.js
var lastAction = Symbol();
var actionId = Symbol();

export {
  onMount,
  listenKeys,
  atom,
  map
};
//# sourceMappingURL=chunk-5KQY4RAJ.js.map
