{
  "version": 3,
  "sources": ["../../nanostores/clean-stores/index.js", "../../nanostores/lifecycle/index.js", "../../nanostores/listen-keys/index.js", "../../nanostores/atom/index.js", "../../nanostores/map/index.js", "../../nanostores/action/index.js"],
  "sourcesContent": ["import { cleanTasks } from '../task/index.js'\n\nexport let clean = Symbol('clean')\n\nexport let cleanStores = (...stores) => {\n  if (process.env.NODE_ENV === 'production') {\n    throw new Error(\n      'cleanStores() can be used only during development or tests'\n    )\n  }\n  cleanTasks()\n  for (let store of stores) {\n    if (store) {\n      if (store.mocked) delete store.mocked\n      if (store[clean]) store[clean]()\n    }\n  }\n}\n", "import { clean } from '../clean-stores/index.js'\n\nconst START = 0\nconst STOP = 1\nconst SET = 2\nconst NOTIFY = 3\nconst MOUNT = 5\nconst UNMOUNT = 6\nconst ACTION = 7\nconst REVERT_MUTATION = 10\n\nexport let on = (object, listener, eventKey, mutateStore) => {\n  object.events = object.events || {}\n  if (!object.events[eventKey + REVERT_MUTATION]) {\n    object.events[eventKey + REVERT_MUTATION] = mutateStore(eventProps => {\n      // eslint-disable-next-line no-sequences\n      object.events[eventKey].reduceRight((event, l) => (l(event), event), {\n        shared: {},\n        ...eventProps\n      })\n    })\n  }\n  object.events[eventKey] = object.events[eventKey] || []\n  object.events[eventKey].push(listener)\n  return () => {\n    let currentListeners = object.events[eventKey]\n    let index = currentListeners.indexOf(listener)\n    currentListeners.splice(index, 1)\n    if (!currentListeners.length) {\n      delete object.events[eventKey]\n      object.events[eventKey + REVERT_MUTATION]()\n      delete object.events[eventKey + REVERT_MUTATION]\n    }\n  }\n}\n\nexport let onStart = (store, listener) =>\n  on(store, listener, START, runListeners => {\n    let originListen = store.listen\n    store.listen = arg => {\n      if (!store.lc && !store.starting) {\n        store.starting = true\n        runListeners()\n        delete store.starting\n      }\n      return originListen(arg)\n    }\n    return () => {\n      store.listen = originListen\n    }\n  })\n\nexport let onStop = (store, listener) =>\n  on(store, listener, STOP, runListeners => {\n    let originOff = store.off\n    store.off = () => {\n      runListeners()\n      originOff()\n    }\n    return () => {\n      store.off = originOff\n    }\n  })\n\nexport let onSet = (store, listener) =>\n  on(store, listener, SET, runListeners => {\n    let originSet = store.set\n    let originSetKey = store.setKey\n    if (store.setKey) {\n      store.setKey = (changed, changedValue) => {\n        let isAborted\n        let abort = () => {\n          isAborted = true\n        }\n\n        runListeners({\n          abort,\n          changed,\n          newValue: { ...store.value, [changed]: changedValue }\n        })\n        if (!isAborted) return originSetKey(changed, changedValue)\n      }\n    }\n    store.set = newValue => {\n      let isAborted\n      let abort = () => {\n        isAborted = true\n      }\n\n      runListeners({ abort, newValue })\n      if (!isAborted) return originSet(newValue)\n    }\n    return () => {\n      store.set = originSet\n      store.setKey = originSetKey\n    }\n  })\n\nexport let onNotify = (store, listener) =>\n  on(store, listener, NOTIFY, runListeners => {\n    let originNotify = store.notify\n    store.notify = changed => {\n      let isAborted\n      let abort = () => {\n        isAborted = true\n      }\n\n      runListeners({ abort, changed })\n      if (!isAborted) return originNotify(changed)\n    }\n    return () => {\n      store.notify = originNotify\n    }\n  })\n\nexport let STORE_UNMOUNT_DELAY = 1000\n\nexport let onMount = (store, initialize) => {\n  let listener = payload => {\n    let destroy = initialize(payload)\n    if (destroy) store.events[UNMOUNT].push(destroy)\n  }\n  return on(store, listener, MOUNT, runListeners => {\n    let originListen = store.listen\n    store.listen = (...args) => {\n      if (!store.lc && !store.active) {\n        store.active = true\n        runListeners()\n      }\n      return originListen(...args)\n    }\n\n    let originOff = store.off\n    store.events[UNMOUNT] = []\n    store.off = () => {\n      originOff()\n      setTimeout(() => {\n        if (store.active && !store.lc) {\n          store.active = false\n          for (let destroy of store.events[UNMOUNT]) destroy()\n          store.events[UNMOUNT] = []\n        }\n      }, STORE_UNMOUNT_DELAY)\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      let originClean = store[clean]\n      store[clean] = () => {\n        for (let destroy of store.events[UNMOUNT]) destroy()\n        store.events[UNMOUNT] = []\n        store.active = false\n        originClean()\n      }\n    }\n\n    return () => {\n      store.listen = originListen\n      store.off = originOff\n    }\n  })\n}\n\n\nexport let onAction = (store, listener) =>\n  on(store, listener, ACTION, runListeners => {\n    let errorListeners = {}\n    let endListeners = {}\n    let originAction = store.action\n    store.action = (id, actionName, args) => {\n      runListeners({\n        id,\n        actionName,\n        args,\n        onEnd: l => {\n          (endListeners[id] || (endListeners[id] = [])).push(l)\n        },\n        onError: l => {\n          (errorListeners[id] || (errorListeners[id] = [])).push(l)\n        }\n      })\n      return [\n        error => {\n          if (errorListeners[id]) {\n            for (let l of errorListeners[id]) l({ error })\n          }\n        },\n        () => {\n          if (endListeners[id]) {\n            for (let l of endListeners[id]) l()\n            delete errorListeners[id]\n            delete endListeners[id]\n          }\n        }\n      ]\n    }\n    return () => {\n      store.action = originAction\n    }\n  })\n", "export function listenKeys(store, keys, listener) {\n  let keysSet = new Set([...keys, undefined])\n  return store.listen((value, changed) => {\n    if (keysSet.has(changed)) {\n      listener(value, changed)\n    }\n  })\n}\n", "import { clean } from '../clean-stores/index.js'\n\nlet listenerQueue = []\n\nexport let notifyId = 0\n\nexport let atom = (initialValue, level) => {\n  let currentListeners\n  let nextListeners = []\n  let store = {\n    lc: 0,\n    l: level || 0,\n    value: initialValue,\n    set(data) {\n      store.value = data\n      store.notify()\n    },\n    get() {\n      if (!store.lc) {\n        store.listen(() => {})()\n      }\n      return store.value\n    },\n    notify(changedKey) {\n      currentListeners = nextListeners\n      let runListenerQueue = !listenerQueue.length\n      for (let i = 0; i < currentListeners.length; i += 2) {\n        listenerQueue.push(\n          currentListeners[i],\n          store.value,\n          changedKey,\n          currentListeners[i + 1]\n        )\n      }\n\n      if (runListenerQueue) {\n        notifyId++\n        for (let i = 0; i < listenerQueue.length; i += 4) {\n          let skip = false\n          for (let j = i + 7; j < listenerQueue.length; j += 4) {\n            if (listenerQueue[j] < listenerQueue[i + 3]) {\n              skip = true\n              break\n            }\n          }\n\n          if (skip) {\n            listenerQueue.push(\n              listenerQueue[i],\n              listenerQueue[i + 1],\n              listenerQueue[i + 2],\n              listenerQueue[i + 3]\n            )\n          } else {\n            listenerQueue[i](listenerQueue[i + 1], listenerQueue[i + 2])\n          }\n        }\n        listenerQueue.length = 0\n      }\n    },\n    listen(listener, listenerLevel) {\n      if (nextListeners === currentListeners) {\n        nextListeners = nextListeners.slice()\n      }\n\n      store.lc = nextListeners.push(listener, listenerLevel || store.l) / 2\n\n      return () => {\n        if (nextListeners === currentListeners) {\n          nextListeners = nextListeners.slice()\n        }\n        let index = nextListeners.indexOf(listener)\n        if (~index) {\n          nextListeners.splice(index, 2)\n          store.lc--\n          if (!store.lc) store.off()\n        }\n      }\n    },\n    subscribe(cb, listenerLevel) {\n      let unbind = store.listen(cb, listenerLevel)\n      cb(store.value)\n      return unbind\n    },\n    off() {} /* It will be called on last listener unsubscribing.\n                We will redefine it in onMount and onStop. */\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    store[clean] = () => {\n      nextListeners = []\n      store.lc = 0\n      store.off()\n    }\n  }\n\n  return store\n}\n", "import { atom } from '../atom/index.js'\n\nexport let map = (value = {}) => {\n  let store = atom(value)\n\n  store.setKey = function (key, newValue) {\n    if (typeof newValue === 'undefined') {\n      if (key in store.value) {\n        store.value = { ...store.value }\n        delete store.value[key]\n        store.notify(key)\n      }\n    } else if (store.value[key] !== newValue) {\n      store.value = {\n        ...store.value,\n        [key]: newValue\n      }\n      store.notify(key)\n    }\n  }\n\n  return store\n}\n", "import { startTask } from '../task/index.js'\n\nexport let lastAction = Symbol()\nexport let actionId = Symbol()\n\nlet uid = 0\n\nexport let doAction = (store, actionName, cb, args) => {\n  let id = ++uid\n  let tracker = { ...store }\n  tracker.set = (...setArgs) => {\n    store[lastAction] = actionName\n    store[actionId] = id\n    store.set(...setArgs)\n    delete store[lastAction]\n    delete store[actionId]\n  }\n  if (store.setKey) {\n    tracker.setKey = (...setArgs) => {\n      store[lastAction] = actionName\n      store[actionId] = id\n      store.setKey(...setArgs)\n      delete store[lastAction]\n      delete store[actionId]\n    }\n  }\n  let result = cb(tracker, ...args)\n  if (result instanceof Promise) {\n    let [err, end] =\n      typeof store.action !== 'undefined'\n        ? store.action(id, actionName, args)\n        : []\n    let endTask = startTask()\n    return result\n      .catch(error => {\n        err && err(error)\n        throw error\n      })\n      .finally(() => {\n        endTask()\n        end && end()\n      })\n  }\n  return result\n}\n\nexport let action =\n  (store, actionName, cb) =>\n  (...args) =>\n    doAction(store, actionName, cb, args)\n"],
  "mappings": "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",
  "names": []
}
